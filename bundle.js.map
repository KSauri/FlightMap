{"version":3,"sources":["webpack:///webpack/bootstrap b6fe041a45d0eaadcac2","webpack:///./js/airports.js","webpack:///./js/a_star.js","webpack:///./js/sand_box.js","webpack:///./js/priority_queue.js","webpack:///./flight_mapping.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACnEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC/FA;;;;;AAKA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU,OAAO;AACjB,YAAY;AACZ,YAAY,0CAA0C;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,iCAAiC,kBAAkB;AACnD,qDAAqD,qBAAqB,EAAE;;AAE5E,wCAAwC,QAAQ,OAAO,YAAY;AACnE;;AAEA,oBAAoB,kBAAkB;AACtC,oBAAoB,kBAAkB;AACtC,oBAAoB,oCAAoC;;;AAGxD,0BAA0B,kBAAkB;;;AAG5C;;;;;;;;;;AAUA;;;;;;;;;;;;ACvFA;AACA;AACA;;AAEA;AACA;;;;AAIA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b6fe041a45d0eaadcac2","const airports = {\n  A: {\n    id: 1,\n    neighbors: {\n      B: 3,\n      F: 5,\n      E: 9\n    },\n    pos: {\n      x: 50,\n      y: 200}\n  },\n  B: {\n    id: 2,\n    neighbors: {\n      C: 6,\n      A: 3,\n      E: 9\n    },\n    pos: {\n      x: 100,\n      y: 100}\n  },\n  C: {\n    id: 3,\n    neighbors: {\n      B: 6,\n      D: 8\n    },\n    pos: {\n      x: 250,\n      y: 50}\n    },\n  D: {\n    id: 4,\n    neighbors: {\n      E: 1,\n      C: 8\n    },\n    pos: {\n      x: 300,\n      y: 180}\n  },\n  E: {\n    id: 5,\n    neighbors: {\n      A: 9,\n      F: 9,\n      D: 1,\n      B: 9\n    },\n    pos: {\n      x: 280,\n      y: 240}\n  },\n  F: {\n    id: 6,\n    neighbors: {\n      E: 9,\n      A: 5\n    },\n    pos: {\n      x: 120,\n      y: 330}\n  }\n};\n\nexport default airports;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/airports.js\n// module id = 0\n// module chunks = 0","import PriorityQueue from './priority_queue';\n\nconst astar = {\n    init: function(airports) {\n        for (var airport in airports) {\n          airports[airport].f = 0;\n          airports[airport].g = 0;\n          airports[airport].g = 0;\n          airports[airport].h = 0;\n          airports[airport].visited = false;\n          airports[airport].closed = false;\n          airports[airport].parent = null;\n        }\n    },\n    heap: function() {\n        return PriorityQueue();\n    },\n    search: function(airports, start, end, diagonal, heuristic) {\n        astar.init(airports);\n        heuristic = heuristic || astar.manhattan;\n        diagonal = !!diagonal;\n        var openHeap = astar.heap();\n        start.f = 100000000000;\n        openHeap.push(start);\n        let paths = {};\n        let pathCount = 0;\n        while(openHeap.length > 0) {\n\n            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n            pathCount ++;\n            var currentAirport = openHeap.shift();\n            paths[pathCount] = [currentAirport];\n            // End case -- result has been found, return the traced path.\n            if(currentAirport === end) {\n\n                // var curr = currentAirport;\n                // var ret = [];\n                // while(curr.parent) {\n                //     ret.push(curr);\n                //     curr = curr.parent;\n                // }\n                // return ret.reverse();\n                return paths;\n            }\n\n            // Normal case -- move currentAirport from open to closed, process each of its neighbors.\n            currentAirport.closed = true;\n            // Find all neighbors for the current node. Optionally find diagonal neighbors as well (false by default).\n            var neighbors = currentAirport.neighbors;\n            for(var neighbor in neighbors) {\n                let neighborAirport = airports[neighbor];\n                neighborAirport.cost = neighbors[neighbor];\n                if(neighborAirport.closed) {\n                    // Not a valid node to process, skip to next neighbor.\n                    continue;\n                }\n                paths[pathCount].push(neighborAirport);\n                // The g score is the shortest distance from start to current node.\n                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n                var gScore = currentAirport.g + neighborAirport.cost;\n                var beenVisited = neighborAirport.visited;\n\n                if(!beenVisited || gScore < neighborAirport.g) {\n\n                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n                    neighborAirport.visited = true;\n                    neighborAirport.parent = currentAirport;\n                    neighborAirport.h = neighborAirport.h || heuristic(neighborAirport.pos, end.pos);\n                    neighborAirport.g = gScore;\n                    neighborAirport.f = neighborAirport.g + neighborAirport.h;\n\n                    if (!beenVisited) {\n                        // Pushing to heap will put it in proper place based on the 'f' value.\n                        openHeap.push(neighborAirport);\n                    }\n                    else {\n                        // Already seen the node, but since it has been rescored we need to reorder it in the heap\n                        openHeap.rescoreElement(neighborAirport);\n                    }\n                }\n            }\n        }\n\n        // No result was found - empty array signifies failure to find path.\n        return [];\n    },\n    manhattan: function(pos0, pos1) {\n        // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n\n        var d1 = Math.abs (pos1.x - pos0.x);\n        var d2 = Math.abs (pos1.y - pos0.y);\n        return d1 + d2;\n    }\n};\n\nexport default astar;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/a_star.js\n// module id = 1\n// module chunks = 0","import airports from './airports';\n\n\n\n\nconst drawAirports = () => {\n\n  var canvas = document.getElementById('canvas');\n  canvas.width = 800;\n  canvas.height = 500;\n  var ctx = canvas.getContext('2d');\n\n\n  for (var airport in airports) {\n    ctx.beginPath();\n    ctx.arc(airports[airport].pos.x, airports[airport].pos.y, 5, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n  }\n};\n\nexport default drawAirports;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/sand_box.js\n// module id = 2\n// module chunks = 0","function PriorityQueue(compare, queue) {\n  if (!(this instanceof PriorityQueue)) return new PriorityQueue(compare, queue);\n\n  compare = compare || min_first;\n  queue   = queue   || [];\n\n  function swap(i, j) {\n    var t = queue[i];\n    queue[i] = queue[j];\n    queue[j] = t;\n  }\n\n  function heapify(i) {\n    var length = queue.length, x, l, r;\n    while (true) {\n      x = i; l = left(i); r = right(i);\n      if (l < length && compare(queue[l], queue[x]) < 0) x = l;\n      if (r < length && compare(queue[r], queue[x]) < 0) x = r;\n      if (x === i) break;\n      swap(i, x);\n      i = x;\n    }\n  }\n\n  function remove(i) {\n    var t = queue[i], b = queue.pop();\n    if (queue.length > 0) {\n      queue[i] = b;\n      heapify(i);\n    }\n    return t;\n  }\n\n  this.peek = () => {\n    return queue[0];\n  };\n\n  // this.deleteAt = (idx) => {\n  //   remove(idx);\n  // };\n\n\n  this.push = function push(/* element, ... */) {\n    var i = queue.length, e = i + arguments.length, j, p;\n    queue.push.apply(queue, arguments);\n    for (; i < e; ++i) {\n      j = i; p = parent(i);\n      for (; j > 0 && compare(queue[j], queue[p]) < 0; j = p, p = parent(j)) {\n        swap(j, p);\n      }\n    }\n    return queue.length;\n  };\n\n  this.rescoreElement = (elToChange) => {\n    oldElIndex = queue.findIndex((el) => {\n      return el.id === elToChange.id;\n    });\n    console.log(oldElIndex);\n    remove(oldElIndex);\n    this.push(elToChange);\n  };\n\n  this.shift = function shift() { return remove(0); };\n  this.__defineGetter__('length', function length() { return queue.length; });\n\n  for (var i = parent(queue.length - 1); i >= 0; --i) { heapify(i); }\n}\n\nfunction left(i)   { return 2 * i + 1; }\nfunction right(i)  { return 2 * i + 2; }\nfunction parent(i) { return Math.floor((i + 1) / 2) - 1; }\n\n\nfunction min_first(a, b) { return a.f - b.f; }\n\n\nexport default PriorityQueue;\n\n\n\n\n\n\n\n\n\n//\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/priority_queue.js\n// module id = 3\n// module chunks = 0","import astar from './js/a_star';\nimport airports from './js/airports';\nimport drawAirports from './js/sand_box';\n\nwindow.astar = astar;\nwindow.airports = airports;\n\n\n\ndrawAirports();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flight_mapping.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}