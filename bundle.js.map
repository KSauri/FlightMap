{"version":3,"sources":["webpack:///webpack/bootstrap 2baba11e3439b21bcc12","webpack:///./js/airports.js","webpack:///./js/a_star.js","webpack:///./js/draw_paths.js","webpack:///./js/generate_paths.js","webpack:///./js/calc_waypoints.js","webpack:///./js/priority_queue.js","webpack:///./flight_mapping.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACnEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnFA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;;;AAGA;AACA,uCAAuC,QAAQ;AAC/C,oBAAoB,wCAAwC;AAC5D,2CAA2C;AAC3C;AACA;AACA;AACA;;;;AAIA;;;;;;;;;;;ACtCA;AACA;AACA;;;;AAIA;AACA;;AAEA,qBAAqB,sCAAsC;AAC3D;AACA,uBAAuB,2CAA2C;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AAWA;;;;;;;;;;;;;;AC9BA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;;;;;;;ACnBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,OAAO;AACjB,YAAY;AACZ,YAAY,0CAA0C;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,iCAAiC,kBAAkB;AACnD,qDAAqD,qBAAqB,EAAE;;AAE5E,wCAAwC,QAAQ,OAAO,YAAY;AACnE;;AAEA,oBAAoB,kBAAkB;AACtC,oBAAoB,kBAAkB;AACtC,oBAAoB,oCAAoC;;AAExD,0BAA0B,kBAAkB;;AAE5C;;;;;;;;;;AAUA;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;;;AAGA;AACA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2baba11e3439b21bcc12","const airports = {\n  A: {\n    id: 1,\n    neighbors: {\n      B: 3,\n      F: 5,\n      E: 9\n    },\n    pos: {\n      x: 50,\n      y: 200}\n  },\n  B: {\n    id: 2,\n    neighbors: {\n      C: 6,\n      A: 3,\n      E: 9\n    },\n    pos: {\n      x: 100,\n      y: 100}\n  },\n  C: {\n    id: 3,\n    neighbors: {\n      B: 6,\n      D: 8\n    },\n    pos: {\n      x: 250,\n      y: 50}\n    },\n  D: {\n    id: 4,\n    neighbors: {\n      E: 1,\n      C: 8\n    },\n    pos: {\n      x: 300,\n      y: 180}\n  },\n  E: {\n    id: 5,\n    neighbors: {\n      A: 9,\n      F: 9,\n      D: 1,\n      B: 9\n    },\n    pos: {\n      x: 280,\n      y: 240}\n  },\n  F: {\n    id: 6,\n    neighbors: {\n      E: 9,\n      A: 5\n    },\n    pos: {\n      x: 120,\n      y: 330}\n  }\n};\n\nexport default airports;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/airports.js\n// module id = 0\n// module chunks = 0","import PriorityQueue from './priority_queue';\n\nconst astar = {\n    init: function(airports) {\n        for (var airport in airports) {\n          airports[airport].f = 0;\n          airports[airport].g = 0;\n          airports[airport].g = 0;\n          airports[airport].h = 0;\n          airports[airport].visited = false;\n          airports[airport].closed = false;\n          airports[airport].parent = null;\n        }\n    },\n    heap: function() {\n        return PriorityQueue();\n    },\n    search: function(airports, start, end, diagonal, heuristic) {\n        astar.init(airports);\n        heuristic = heuristic || astar.manhattan;\n        diagonal = !!diagonal;\n        var openHeap = astar.heap();\n        start.f = 100000000000;\n        openHeap.push(start);\n        let paths = [];\n        while(openHeap.length > 0) {\n\n            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n            var currentAirport = openHeap.shift();\n            paths.push([currentAirport]);\n            // End case -- result has been found, return the traced path.\n            if(currentAirport === end) {\n                return paths;\n            }\n\n            // Normal case -- move currentAirport from open to closed, process each of its neighbors.\n            currentAirport.closed = true;\n            // Find all neighbors for the current node. Optionally find diagonal neighbors as well (false by default).\n            var neighbors = currentAirport.neighbors;\n            for(var neighbor in neighbors) {\n                let neighborAirport = airports[neighbor];\n                neighborAirport.cost = neighbors[neighbor];\n                if(neighborAirport.closed) {\n                    \n                    continue;\n                }\n                paths[paths.length - 1].push(neighborAirport);\n                var gScore = currentAirport.g + neighborAirport.cost;\n                var beenVisited = neighborAirport.visited;\n\n                if(!beenVisited || gScore < neighborAirport.g) {\n\n                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n                    neighborAirport.visited = true;\n                    neighborAirport.parent = currentAirport;\n                    neighborAirport.h = neighborAirport.h || heuristic(neighborAirport.pos, end.pos);\n                    neighborAirport.g = gScore;\n                    neighborAirport.f = neighborAirport.g + neighborAirport.h;\n\n                    if (!beenVisited) {\n                        // Pushing to heap will put it in proper place based on the 'f' value.\n                        openHeap.push(neighborAirport);\n                    }\n                    else {\n                        // Already seen the node, but since it has been rescored we need to reorder it in the heap\n                        openHeap.rescoreElement(neighborAirport);\n                    }\n                }\n            }\n        }\n\n        // No result was found - empty array signifies failure to find path.\n        return [];\n    },\n    manhattan: function(pos0, pos1) {\n        // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n\n        var d1 = Math.abs (pos1.x - pos0.x);\n        var d2 = Math.abs (pos1.y - pos0.y);\n        return d1 + d2;\n    }\n};\n\nexport default astar;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/a_star.js\n// module id = 1\n// module chunks = 0","var canvas = document.getElementById('canvas');\nvar ctx = canvas.getContext('2d');\n\nconst drawLineSegment = (pos, idx) => {\n  ctx.beginPath();\n  ctx.moveTo(pos[idx - 1].x, pos[idx - 1].y);\n  ctx.lineTo(pos[idx].x, pos[idx].y);\n  ctx.stroke();\n  ctx.closePath();\n};\n\nfunction animate(total, ptsArr, idx, subidx, cb) {\n    const reAnimate = () => {\n      animate(total, ptsArr, idx, subidx, cb);\n    };\n    if (total < ptsArr[idx][subidx].length - 1) {\n        requestAnimationFrame(reAnimate);\n    } else {\n      idx ++;\n      if (cb !== undefined) { cb(ptsArr, idx); }\n      return;\n    }\n    drawLineSegment(ptsArr[idx][subidx], total);\n    total++;\n}\n\n\nconst drawPathGenerations = (pathGens, generation = 0) => {\n  if (generation === pathGens.length) { return; }\n  for (var path = 0; path < pathGens[generation].length - 1; path++) {\n    animate(1, pathGens, generation, path); // only one path calls drawPathGenerations to draw the next gen\n  }\n  let curr = pathGens[generation].length - 1;\n  animate(1, pathGens, generation, curr, drawPathGenerations);\n};\n\n\n\nexport default drawPathGenerations;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/draw_paths.js\n// module id = 2\n// module chunks = 0","import calcWaypoints from './calc_waypoints';\nimport astar from './a_star';\nimport airports from './airports';\n\n\n\nlet paths = [];\nlet pathGenerations = astar.search(airports, airports.A, airports.D);\n\nfor (var pathGen = 0; pathGen < pathGenerations.length - 1; pathGen++) {\n  paths.push([]);\n  for (var airport = 1; airport < pathGenerations[pathGen].length; airport++) {\n    let wayPoints = calcWaypoints([pathGenerations[pathGen][0].pos,\n      pathGenerations[pathGen][airport].pos]);\n    paths[pathGen]\n      .push(wayPoints);\n  }\n}\n\nexport default paths;\n\n\n\n\n\n\n\n\n\n\n//\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/generate_paths.js\n// module id = 3\n// module chunks = 0","const calcWaypoints = (verts) => {\n    var waypoints = [];\n    for (var i = 1; i < verts.length; i++) {\n        var pt0 = verts[i - 1];\n        var pt1 = verts[i];\n        var dx = pt1.x - pt0.x;\n        var dy = pt1.y - pt0.y;\n        for (var j = 0; j < 100; j++) {\n            var x = pt0.x + dx * j / 100;\n            var y = pt0.y + dy * j / 100;\n            waypoints.push({\n                x: x,\n                y: y\n            });\n        }\n    }\n    return (waypoints);\n};\n\nexport default calcWaypoints;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/calc_waypoints.js\n// module id = 5\n// module chunks = 0","function PriorityQueue(compare, queue) {\n  if (!(this instanceof PriorityQueue)) return new PriorityQueue(compare, queue);\n\n  compare = compare || min_first;\n  queue   = queue   || [];\n\n  function swap(i, j) {\n    var t = queue[i];\n    queue[i] = queue[j];\n    queue[j] = t;\n  }\n\n  function heapify(i) {\n    var length = queue.length, x, l, r;\n    while (true) {\n      x = i; l = left(i); r = right(i);\n      if (l < length && compare(queue[l], queue[x]) < 0) x = l;\n      if (r < length && compare(queue[r], queue[x]) < 0) x = r;\n      if (x === i) break;\n      swap(i, x);\n      i = x;\n    }\n  }\n\n  function remove(i) {\n    var t = queue[i], b = queue.pop();\n    if (queue.length > 0) {\n      queue[i] = b;\n      heapify(i);\n    }\n    return t;\n  }\n\n  this.peek = () => {\n    return queue[0];\n  };\n\n  this.push = function push(/* element, ... */) {\n    var i = queue.length, e = i + arguments.length, j, p;\n    queue.push.apply(queue, arguments);\n    for (; i < e; ++i) {\n      j = i; p = parent(i);\n      for (; j > 0 && compare(queue[j], queue[p]) < 0; j = p, p = parent(j)) {\n        swap(j, p);\n      }\n    }\n    return queue.length;\n  };\n\n  this.rescoreElement = (elToChange) => {\n    oldElIndex = queue.findIndex((el) => {\n      return el.id === elToChange.id;\n    });\n    console.log(oldElIndex);\n    remove(oldElIndex);\n    this.push(elToChange);\n  };\n\n  this.shift = function shift() { return remove(0); };\n  this.__defineGetter__('length', function length() { return queue.length; });\n\n  for (var i = parent(queue.length - 1); i >= 0; --i) { heapify(i); }\n}\n\nfunction left(i)   { return 2 * i + 1; }\nfunction right(i)  { return 2 * i + 2; }\nfunction parent(i) { return Math.floor((i + 1) / 2) - 1; }\n\nfunction min_first(a, b) { return a.f - b.f; }\n\nexport default PriorityQueue;\n\n\n\n\n\n\n\n\n\n//\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/priority_queue.js\n// module id = 6\n// module chunks = 0","import astar from './js/a_star';\nimport airports from './js/airports';\nimport drawAirports from './js/sand_box';\nimport drawPathGenerations from './js/draw_paths';\nimport paths from './js/generate_paths';\n\n\ndrawAirports();\ndrawPathGenerations(paths);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flight_mapping.js\n// module id = 7\n// module chunks = 0"],"sourceRoot":""}